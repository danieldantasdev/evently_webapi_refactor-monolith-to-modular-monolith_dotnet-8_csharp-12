Após identificar candidatos a módulo, é essencial avaliar se essas divisões são adequadas – isto é, se atendem a critérios de qualidade de arquitetura modular. Módulos “bons” devem exibir baixo acoplamento entre si e alta coesão interna, além de facilitar testabilidade, manutenção, evolução e eventualmente suportar escalabilidade da aplicação. A avaliação pode ser realizada tanto por métricas objetivas quanto por análise qualitativa (inspeções e feedback da equipe). Abaixo, discutimos os principais critérios de qualidade e como saber se os módulos atendem a cada um, bem como práticas de refinamento contínuo.

### 4.1 Baixo Acoplamento

Acoplamento se refere ao grau de dependência entre módulos – módulos bem projetados minimizam essas dependências. Na prática, isso significa que um módulo deve poder funcionar (e ser desenvolvido ou modificado) com pouca ou nenhuma necessidade de conhecer detalhes internos de outros módulos. Critérios de baixo acoplamento incluem:

- Interfaces Claras e Poucas Dependências Externas: Cada módulo idealmente expõe uma interface (API interna) e oculta seus detalhes. O número de chamadas de um módulo A para outro B deve ser pequeno e bem definido. Métricas de efferent coupling (número de outros módulos que um módulo invoca) e afferent coupling (número de módulos que invocam este módulo) quantificam isso ￼ ￼. Por exemplo, se o módulo Relatórios depende de 5 outros módulos para funcionar, ele tem alto acoplamento de saída (efferent); isso pode indicar que sua função não está bem delimitada ou que deveria ser subdividido.
- Independência de Implementação: Mudanças internas em um módulo não deveriam quebrar outros módulos. Um sinal de baixo acoplamento é quando modificações no código de um módulo raramente requerem alterações em outro – algo que pode ser medido pelo histórico de commits (poucas co-mudanças entre módulos) e também observado via testes de regressão (módulo A pode ser alterado sem falhar testes do módulo B).
- Métricas de Acoplamento: Estudos acadêmicos apontam coupling e cohesion como as métricas mais tradicionais e importantes na avaliação de modularidade ￼. Variantes objetivas incluem: instabilidade (proporção de dependências de saída sobre total de dependências – valor baixo indica módulo mais estável, pois muitos dependem dele mas ele depende de poucos ￼), número de interfaces públicas (por ex., métrica IFN: quantas interfaces o módulo expõe para outros ￼), ou simplesmente contagem de chamadas inter-modulares. Um diagrama de dependência entre módulos deve idealmente formar um gráfico desacoplado (de preferência acíclico) – se houver ciclos de acoplamento (A depende de B e B de A), a modularização está comprometida. Ferramentas como análise de Dependency Structure Matrix (DSM) podem calcular um índice de acoplamento geral do sistema. Em suma, “baixo acoplamento” se manifesta numericamente por poucos pontos de interação entre módulos e baixo fluxo de dependências em ambos os sentidos ￼.

### 4.2 Alta Coesão

Coesão é o grau em que os elementos internos de um módulo estão relacionados e trabalham juntos para a mesma finalidade. Um módulo altamente coeso concentra funcionalidades estreitamente ligadas entre si (por exemplo, todas referentes a gerenciamento de clientes) e não mistura responsabilidades díspares. Para avaliar coesão:

- Responsabilidade Única: Cada módulo deve implementar idealmente uma responsabilidade ou funcionalidade central do sistema (ou um conjunto de funcionalidades muito relacionadas). Abgaz et al. apontam que coesão pode ser vista como medida do “princípio da responsabilidade única” aplicado ao serviço/módulo ￼ ￼. Se ao revisar um módulo encontramos múltiplos objetivos não relacionados (ex.: o módulo Usuários também gera relatórios financeiros), então ele tem coesão baixa. Revisões de design e inspeções manuais ajudam a detectar esses cheiros de baixa coesão.
- Interconexão Interna vs. Externa: Um indicador é a razão entre comunicações internas e externas. Métricas de coesão clássicas como LCOM (Lack of Cohesion of Methods) podem ser agregadas para o nível de módulo – LCOM alto indica que as classes do módulo pouco interagem entre si (baixa coesão) ￼. Outras métricas citadas incluem CHM (Cohesion at Message level) e CHD (Cohesion at Domain level) que quantificam coesão considerando comunicação entre classes e similaridade de conceitos no domínio do módulo ￼. Por exemplo, CHD verifica se as classes de um módulo compartilham muitos termos de domínio (alta similaridade conceitual significa alta coesão temática) ￼. Se um módulo tem funções totalmente independentes que nunca se chamam ou não compartilham conceitos de dados, possivelmente deveria ser separado em módulos menores.
- Cálculo de Coesão Estrutural: Algumas abordagens medem coesão pela densidade de conexões internas: número de chamadas ou relações entre componentes dentro do módulo em relação ao número máximo possível. Também existe o conceito de modularidade estrutural (SMQ) que combina similaridade estrutural (número de chamadas internas) e similaridade conceitual (vocabulário comum) para avaliar o quão forte é a unidade formada pelo módulo ￼ ￼. Módulos bons tendem a ter SMQ alto – seus componentes são fortemente conectados e semânticamente próximos.
- Verificação Empírica: Podemos olhar para a implementação: se ao fazer uma mudança funcional, quase todas as alterações ocorrem dentro de um mesmo módulo, isso sugere boa coesão (o módulo concentra a lógica relevante). Por outro lado, se implementar uma única feature exige tocar muitos módulos diferentes, talvez as responsabilidades estejam mal distribuídas (coesão difusa). Durante a fase de prototipação, construir mapas de calor de mudanças ou execução dentro de módulos por funcionalidade pode revelar se cada módulo é internamente coeso em termos de comportamento.

Resumo de Acoplamento vs. Coesão: Em geral, buscamos baixo acoplamento entre módulos e alta coesão dentro de cada módulo – essa combinação favorece a independência e a clareza. Abgaz et al. enfatizam que praticamente todas as extrações automatizadas dependem de variações desses critérios de acoplamento/cohesão ￼. Uma boa modularização normalmente aparece como tal também nas métricas: acoplamento (dependência externa) baixo e coesão (conectividade interna) alta são objetivos quantificáveis ￼ ￼.

### 4.3 Facilidade de Testes (Testabilidade)

Módulos bem definidos facilitam a escrita de testes isolados para suas funcionalidades, pois possuem interfaces claras e poucas dependências externas. Para avaliar testabilidade:

- Capacidade de Isolamento: Deve ser possível instanciar ou utilizar um módulo (ou seus componentes principais) em um ambiente de teste simulando ou “mockando” interações com outros módulos. Se há baixo acoplamento, consegue-se substituir módulos vizinhos por dublês (mocks/stubs) facilmente nos testes. Por exemplo, um módulo Catálogo pode ser testado simulando-se as respostas do módulo Usuários se precisar de autenticação, mas sem precisar de toda a aplicação rodando.
- Cobertura de Testes por Módulo: Verifica-se se cada módulo pode atingir alta cobertura de testes unitários/integrados focados nele próprio. Se certos módulos são difíceis de testar isoladamente (ex.: porque invocam em demasia serviços globais ou dependem de estado compartilhado), é indício de modularização imperfeita. Módulos bons expõem pontos de entrada bem definidos para suas funcionalidades que podem ser invocados em testes.
- Tempo de Build/Teste: Em arquiteturas modulares, idealmente deve-se conseguir compilar e testar módulos independentemente. Embora num monólito modular completo isso possa não ser totalmente possível (já que é um só deploy), métricas como o tempo de execução de testes de um módulo podem indicar se ele é razoavelmente independente. Se adicionar um teste para o módulo A requer configurar todo o contexto de B, C e D, há problema de acoplamento.
- Relato Qualitativo dos Desenvolvedores: Muitas vezes, a testabilidade é percebida pela equipe – módulos “bons” são aqueles em que os desenvolvedores conseguem escrever testes de unidade facilmente, enquanto módulos ruins levam a testes complexos ou altamente acoplados. Feedback da equipe de QA e dev é útil: por exemplo, “O módulo X consegue ser testado com mocks simples, mas o Y exige um banco de dados inteiro e vários módulos ligados para testar uma única função”.

Em resumo, um módulo adequado melhora a testabilidade porque isola comportamentos. Isso não apenas aumenta a qualidade do software como serve de confirmação de boa separação de preocupações. Alguns projetos adotam inclusive a prática de primeiro escrever testes de contrato para o que seria cada módulo e verificar se as dependências são mínimas (TDD de arquitetura).

### 4.4 Manutenibilidade e Evolução

Manutenibilidade engloba quão fácil é compreender, modificar e corrigir um módulo, e evolução refere-se à capacidade de acrescentar novas funcionalidades ou mudanças arquiteturais com impacto controlado. Módulos bem projetados contribuem para:

- Localidade de Mudanças: Alterações de requisitos ou correções de bugs devem afetar apenas um ou poucos módulos. Uma modularização de qualidade exibe baixo espalhamento de mudanças – isto pode ser medido observando-se quantos módulos tocam em média por issue corrigido ou feature implementada. Se frequentemente um único change request implica modificar 5 módulos diferentes, as fronteiras podem não estar adequadas. O objetivo é que cada feature ou concern do sistema esteja encapsulado em um módulo principal.
- Facilidade de Compreensão: Cada módulo forma uma unidade lógica que pode ser compreendida isoladamente. Isso melhora a analizabilidade (subatributo da manutenibilidade segundo ISO 25010): um novo desenvolvedor consegue entender o módulo Pagamento sem precisar ler todo o resto do sistema. Indicadores podem ser subjetivos (feedback da equipe sobre complexidade) e objetivos (tamanho médio de módulo – módulos extremamente grandes podem ser difíceis de entender, enquanto minúsculos demais podem significar fragmentação desnecessária).
- Proteção contra Regressões: Com módulos independentes e bem testados, mudanças em um módulo devem causar pouco risco de efeitos colaterais. A presença de baixo acoplamento novamente é chave aqui – se um módulo é modificado e outro quebra, havia um acoplamento oculto. Monitorar bugs introduzidos em áreas aparentemente não relacionadas pode sinalizar problemas de limites modulares.
- Evolvabilidade Arquitetural: Uma arquitetura modular é mais adaptável a mudanças tecnológicas ou de escala. Por exemplo, se decide-se migrar parte da aplicação para um novo framework, pode-se fazer módulo por módulo. Abgaz et al. notam que acoplamento, coesão, modularidade e evolutibilidade estão correlacionados – bons valores de acoplamento/coesia contribuem diretamente para maior capacidade de evoluir ￼. Até métricas de evolvabilidade foram propostas, mas geralmente se concentram em medir os anteriores (complexidade, dependências, etc. que afetam evolução).

Podemos utilizar métricas de código como suporte: tamanho médio do módulo (em linhas de código ou número de classes) – nem tão grande que seja um “mini-monólito”, nem tão pequeno que dispersa lógica coesa; índice de complexidade ciclomática por módulo; razões de comentário ou documentação por módulo (módulos confusos tendem a exigir mais documentação para serem entendidos). No entanto, manutenibilidade tem um forte componente qualitativo. Revisões de código e design periódicas são uma ferramenta: arquitetos podem verificar se as mudanças recentes se confinaram aos módulos esperados ou se estão violando a arquitetura. Se um desenvolvedor frequentemente comenta “precisei mexer em módulo X porque a lógica que eu precisava estava lá mas na verdade era parte da minha história em Y”, isso é um cheiro de modularização incorreta.

Em suma, um módulo “bom” torna mais fácil consertar e crescer o sistema. Já módulos mal delineados geram efeitos cascata de mudança, são difíceis de entender isoladamente e geralmente viram gargalos no desenvolvimento.

### 4.5 Escalabilidade (de Desenvolvimento e de Operação)

Embora a escalabilidade de desempenho em runtime seja mais relacionada a arquiteturas distribuídas, a modularização influencia escalabilidade em dois sentidos: a escalabilidade do desenvolvimento (múltiplos times trabalhando em paralelo) e a preparação para escalabilidade técnica futura (por exemplo, extrair um módulo para um microsserviço independente para escalar horizontalmente apenas aquela parte).

- Escalabilidade do Desenvolvimento (Parallelismo): Com módulos claramente separados e de baixo acoplamento, diferentes equipes ou desenvolvedores podem trabalhar em módulos diferentes simultaneamente com mínimo interferência. Ou seja, a arquitetura suporta desenvolvimento paralelo escalável. Se os módulos são bem definidos, cada equipe pode ter propriedade de um conjunto deles (Conway já dizia: a estrutura organizacional reflete-se na modularização do software). Um sinal de boa modularidade aqui é quando merges e conflitos no versionamento diminuem – porque diferentes módulos implicam menos colisão no mesmo arquivo. Organizações muitas vezes avaliam isso atribuindo “áreas de código” a times: se essas áreas raramente se sobrepõem, a modularização ajuda a escalar a equipe.
- Prontidão para Escalar Arquiteturalmente: Em termos de desempenho e implantação, um monólito modular bem projetado permite que módulos críticos sejam extraídos em microsserviços no futuro com esforço controlado ￼ ￼. Por exemplo, se o módulo Processamento de Imagens começa a demandar escalabilidade específica, ele poderia ser destacado do monólito sem grandes refatorações – isso será viável se suas dependências com o restante já estão limitadas por interfaces claras (baixo acoplamento) e ele já gerencia seus próprios dados ou esquemas. Assim, avaliar escalabilidade é também simular cenários de carga: um módulo intensivo (ex.: Busca) pode tornar-se candidato à separação; se atualmente esse módulo está fortemente acoplado a outros, a modularização não é ótima do ponto de vista de escalabilidade.
- Métricas de Performance por Módulo: Embora dentro de um monólito puro não se isole facilmente consumo de recursos por módulo, pode-se instrumentar para ver CPU/memória gastos em funcionalidades correspondentes a cada módulo. Módulos independentes permitirão escalabilidade selectiva – em microservices isso seria escalar só aquele serviço. No monólito modular, isso poderia significar permitir threads ou recursos específicos para aquele subsistema. Se um módulo é muito acoplado, não conseguimos isolá-lo para otimizar desempenho. Em avaliações experimentais, pesquisadores mediram tempos de execução ou consumo antes e depois de extrair serviços ￼; aplicando analogamente, se modularização interna não penaliza desempenho e talvez até melhore (por organização de código), é um ponto positivo. De todo modo, escalabilidade no monólito modular é principalmente um atributo de estrutura para futuro – módulos bem separados facilitam dividir a aplicação quando necessário (seja via microsserviços, seja carregando módulos dinamicamente, etc.).

### 4.6 Uso de Métricas Objetivas

Conforme mencionado, diversas métricas quantitativas auxiliam na avaliação de acoplamento e coesão. Recapitulando as principais e como interpretá-las:

- Número de Dependências Entre Módulos: contagem de chamadas ou referências de dados de um módulo a outro. Deve ser minimizado. Pode-se montar uma matriz módulo x módulo de dependências e calcular, por exemplo, a porcentagem de células não vazias (um Coupling Factor global). Idealmente poucos pares de módulos se comunicam, e quando o fazem, é através de um número limitado de pontos.
- Afferent/Efferent Coupling: número de módulos que dependem de X (afferent) versus de quantos X depende (efferent). Módulos centrais e estáveis têm afferent alto e efferent baixo; módulos utilitários ou de nível inferior podem ter efferent um pouco maior. Extremes são ruins: efferent muito alto (módulo depende de muitos outros) = instável; afferent muito alto (módulo muito dependido) mas se não for bem projetado = potencial gargalo para mudanças. Essas métricas vêm de Robert Martin e foram usadas em pesquisas ￼ ￼.
- Instabilidade (I): calculada como Efferent / (Afferent + Efferent) – varia de 0 (módulo totalmente independente, só dependências entrantes) a 1 (módulo “dependente” de todos, nenhuma dependência entra). Em sistemas bem arquitetados, espera-se módulos de núcleo mais estáveis (I próximo de 0) e módulos periféricos mais instáveis (I mais alto), mas nenhum deveria ser extremo. Avaliar o I médio do sistema ou identificar módulos com I anômalo ajuda a apontar possíveis problemas ￼.
- Lack of Cohesion of Methods (LCOM) ou variações: originalmente para classes, mas pode ser aplicado agrupando métodos de classes de um módulo. Um LCOM alto sugere que o módulo realiza tarefas diversas não relacionadas. Pesquisas reportam uso de LCOM adaptado para avaliar microserviços ￼ – o mesmo vale para módulos: se métodos dentro do módulo não compartilham estado ou uso comum, o módulo pode carecer de foco.
- Tamanho do Módulo: número de classes ou LOC. Embora não haja um número “certo”, extremos são indesejáveis. Alguns trabalhos consideram métrica de distribuição de tamanhos – por ex., Non-Extreme Distribution (NED) mede se há equilíbrio no tamanho dos clusters (evitando módulos enormes ou minúsculos) ￼. Um módulo muito grande pode violar coesão (contém submódulos implícitos dentro dele), enquanto módulos muito pequenos talvez aumentem acoplamento (se dividiu funcionalidade coesa em pedaços arbitrários). A modularização deve ser granular o suficiente para separar domínios, mas não tanto a ponto de fragmentar indevidamente funcionalidades fortemente relacionadas.
- Cobertura de testes por módulo: percentagem de código de cada módulo coberta por testes. Módulos com baixa cobertura podem indicar dificuldades de teste (talvez acoplamento alto impedindo isolamento) ou arquitetura não testável. Esse é um indicador indireto de qualidade modular.
- Métricas de qualidade internas: como complexidade ciclomática média por classe do módulo, profundidade de dependência interna, etc., podem complementar. Um módulo pode ser coeso mas internamente muito complexo – isso é um problema de design interno, não tanto de modularização, mas se um módulo apresenta complexidade extrema, talvez pudesse ser subdividido em sub-módulos ou componentes internos.

Na literatura de avaliação de decomposição, observou-se que quase todos os trabalhos recentes utilizam métricas para avaliar seus módulos/serviços candidatos ￼ ￼. Coupling e cohesion aparecem consistentemente como os mais importantes e com suporte de longa data ￼, embora com variações de definição em cada estudo. Portanto, na prática industrial, faz sentido adotar um conjunto padrão de métricas para acompanhar a qualidade modular ao longo do tempo ￼. Ferramentas como SonarQube podem ser configuradas para rastrear acoplamento entre componentes, e há bibliotecas para calcular métricas como instability e LCOM.

### 4.7 Avaliação Qualitativa e Critérios Adicionais

Além das métricas, avaliação qualitativa por arquitetos e desenvolvedores experientes é crucial:

- Revisões Arquiteturais: Após a modularização, realizar code reviews focadas na arquitetura – verificar se cada módulo tem uma intenção clara, se as interfaces estão bem definidas, se não há “atalhos” entre módulos (e.g., um módulo acessando banco de outro diretamente, o que violaria a independência). Checklist qualitativo: O nome do módulo reflete bem sua responsabilidade? Poderia este módulo ser extraído como um serviço independente facilmente? Há partes do código que ainda parecem pertencer a outro módulo?
- Feedback de Desenvolvedores: Coletar a opinião da equipe que trabalha com o código modularizado: eles sentem que agora o código está mais organizado? Os módulos correspondem às expectativas? Há ainda áreas de confusão? Muitas vezes, desenvolvedores apontam “este módulo A ainda está muito acoplado com B, sempre que mexemos em A temos que tocar B” – essa informação qualitativa direciona refinamentos. Satisfação do desenvolvedor pode ser um sinal: módulos bons tendem a ser apreciados pela facilidade, módulos ruins geram reclamações.
- Validação com Stakeholders de Negócio: Embora em menor grau, perguntar a partes interessadas se as fronteiras modulares correspondem a divisões de domínio compreensíveis para elas ajuda a confirmar alinhamento semântico. Por exemplo, a equipe de suporte consegue facilmente delimitar que um bug pertence ao módulo X? Se a modularização faz sentido, termos de negócio usados nos módulos serão familiares aos stakeholders.
- Conformidade com Requisitos Não-Funcionais: Avaliar se a modularização atende a restrições específicas, p. ex., um módulo pode ser responsável por dados regulados (LGPD, PCI) e assim exigia isolamento – se foi devidamente isolado, atende a esse requisito. Ou requisitos de performance: um módulo crítico foi mantido pequeno e otimizado.

Outros critérios de modularidade incluem reutilização (um módulo bem definido poderia em tese ser reutilizado em outro contexto ou projeto), mas na prática para monólitos modulares o foco principal é facilitar a manutenção incremental do mesmo sistema.

### 4.8 Refinamento Contínuo dos Módulos (Iteratividade)

A avaliação de modularização não é um evento único – ela deve ser contínua e iterativa. À medida que o sistema evolui, pode ser necessário refinar os limites dos módulos. Novos requisitos podem sugerir subdividir um módulo muito grande ou, inversamente, fundir módulos cuja separação se mostrou artificial. Boas práticas para esse processo contínuo incluem:

- Medição Contínua de Métricas: Integrar as métricas de acoplamento/coesão no pipeline de integração contínua ou em relatórios periódicos. Assim, a equipe pode monitorar tendências – por exemplo, se o acoplamento entre dois módulos está aumentando ao longo do tempo (talvez devido a novas funcionalidades criando ligações), isso sinaliza necessidade de intervenção arquitetural antes que vire débito técnico severo. Abgaz et al. apontam a falta de padronização de métricas como um gap na literatura ￼, mas recomendam estabelecer um conjunto consistente para uso prático ￼. Em contexto industrial, pode-se adotar um score de modularidade combinando vários indicadores e acompanhar sua variação release a release.
- Refinamento Iterativo: Adotar uma abordagem ágil para arquitetura, onde a modularização é revista em retrospectivas técnicas. Por exemplo, após cada versão maior, o time de arquitetura revisita o desenho modular: Os módulos ainda fazem sentido com as novas features adicionadas? Algum módulo cresceu demais e deveria ser quebrado? Dois módulos acabaram interagindo mais do que o previsto – precisamos redefinir suas fronteiras? Esse processo incremental garante que a arquitetura não degrade com o tempo.
- Provas de Conceito e Experimentos: Para módulos críticos ou duvidosos, pode-se fazer pequenos experimentos de refatoração antes de um compromisso maior. Ex: suspeita-se que os módulos Pedido e Carrinho estão mal separados – experimentar fundi-los temporariamente ou separar uma parte como módulo próprio em um branch para ver se métricas e clareza melhoram. Esse tipo de spike arquitetural ajuda a tomar decisões embasadas.
- Feedback de Usuários e Requisitos Novos: Curiosamente, até feedback de usuários finais pode orientar modularização – se usuários pedem muitas evoluções num certo conjunto de funcionalidades que atualmente está espalhado em vários módulos, isso indica potencial ganho em reorganizá-los. Do ponto de vista de produto, manter módulos alinhados com áreas de valor do usuário facilita planejar releases independentes por módulo (no contexto de microsserviços, isso é evidente; no modular monolith, isso pode significar equipes focadas em módulos).
- Documentação e Conhecimento Compartilhado: Manter a documentação da arquitetura modular atualizada (por exemplo, o mapa de módulos e suas dependências) é importante para novos membros entenderem e para evitar violações inadvertidas. Quando alguém trabalha sem saber dos limites, pode introduzir um acesso incorreto entre módulos – daí a importância de comunicar claramente a estrutura modular e talvez automatizar enforcement (ferramentas que impedem dependências indevidas, como restrições de pacote ou análises estáticas personalizadas).

Em última instância, sabemos que modularizar um sistema grande é um processo iterativo de convergência. Raramente a primeira divisão é perfeita; por isso, aplicar os critérios e métricas acima repetidamente ao longo do tempo, e ajustar conforme necessário, faz parte das boas práticas de engenharia de software. Esse refinamento contínuo garante que o monólito modular permaneça saudável, com módulos verdadeiramente independentes e coesos mesmo com a evolução do sistema. Como sintetizado por Abgaz et al. (2023), mesmo ao optar por um modular monolith em vez de microsserviços, deve-se seguir fases similares de análise e avaliação, e os benefícios serão colhidos em termos de manutenibilidade e qualidade arquitetural geral ￼.

### Tabela 2: Critérios e Métodos para Avaliação da Qualidade dos Módulos

| Critério                        | Descrição                                                                                                                                                                                                         | Exemplos/Indicadores                                                                                                                                                                                                                                                                                                                                     |
| ------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Baixo Acoplamento**           | Os módulos devem ter poucas dependências entre si, de modo que mudanças em um módulo não exijam alterações significativas em outros.                                                                              | - Interfaces claras e restritas (API interna bem definida).<br>- Métricas: _Efferent/Afferent Coupling_ e _Instabilidade (I)_.<br>- Diagrama de dependências desacoplado (idealmente acíclico; sem ciclos como A depende de B e B de A).                                                                                                                 |
| **Alta Coesão**                 | Os elementos internos de cada módulo devem estar intimamente relacionados, realizando uma única função ou responsabilidade.                                                                                       | - Responsabilidade única (ex.: um módulo "Usuários" que não engloba funções financeiras).<br>- Métricas: _LCOM_ (Lack of Cohesion of Methods), _Cohesion at Message/Domain Level (CHM/CHD)_ ou _SMQ_ (modularidade estrutural).<br>- Relação entre comunicação interna (alta) versus externa (baixa).                                                    |
| **Facilidade de Testes**        | O módulo deve permitir a criação de testes unitários e de integração de forma isolada, evidenciando que sua interface e dependências são bem definidas.                                                           | - Capacidade de isolar o módulo por meio de _mocks_ ou _stubs_.<br>- Alta cobertura de testes por módulo.<br>- Tempo reduzido de build/test.<br>- Feedback positivo dos desenvolvedores quanto à testabilidade.                                                                                                                                          |
| **Manutenibilidade e Evolução** | O módulo deve ser de fácil compreensão, modificação e correção, permitindo que mudanças de requisitos afetem preferencialmente somente o módulo em questão.                                                       | - Localidade de mudanças: alterações concentradas em um único módulo.<br>- Facilidade de compreensão (analizabilidade).<br>- Baixo espalhamento de alterações (verificado via histórico de commits ou feedback dos times).                                                                                                                               |
| **Escalabilidade**              | Os módulos devem facilitar o trabalho paralelo de equipes e permitir a extração ou isolamento de funcionalidades críticas, caso seja necessário escalá-las (por exemplo, convertendo um módulo em microsserviço). | - Menores conflitos de merge no versionamento.<br>- Separação clara de áreas de código, possibilitando escalabilidade seletiva.<br>- Capacidade de isolar módulos críticos para futura extração quando a demanda por escalabilidade aumentar.                                                                                                            |
| **Métricas Objetivas**          | A utilização de métricas quantitativas auxilia na verificação dos critérios arquiteturais e serve de base para decisões de refinamento e evolução da modularização.                                               | - Número de dependências entre módulos (matriz módulo x módulo).<br>- Índice de instabilidade.<br>- LCOM e variações para medir coesão.<br>- Tamanho dos módulos (LOC, número de classes).<br>- Cobertura de testes por módulo.<br>- Ferramentas: SonarQube, Dependency Structure Matrix (DSM) e outras que possibilitem quantificação das dependências. |
| **Avaliação Qualitativa**       | A análise por arquitetos e desenvolvedores é fundamental para confirmar a clareza, o propósito e a viabilidade dos módulos na prática, complementando as métricas quantitativas.                                  | - Code reviews focadas na arquitetura.<br>- Feedback dos desenvolvedores sobre a facilidade de uso e manutenção dos módulos.<br>- Verificação se os nomes e limites dos módulos refletem o domínio do negócio.<br>- Revisões periódicas para identificar “cheiros” de arquitetura inadequada.                                                            |
| **Refinamento Iterativo**       | A avaliação e a modularização devem ser monitoradas e ajustadas continuamente, acompanhando a evolução do sistema e as necessidades do negócio.                                                                   | - Integração das métricas no pipeline de CI.<br>- Revisões arquiteturais periódicas (retrospectivas técnicas).<br>- Provas de conceito (spikes) para testar refatorações em módulos suspeitos.<br>- Documentação atualizada do mapa de módulos e dependências.                                                                                           |
